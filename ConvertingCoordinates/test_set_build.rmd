---
title: "R Notebook"
author: james
date: 11/26/2020
output: html_document
---

### Purpose
Add columns to our current tsv that can identify single exon ASOs, exon-exon ASOs, UTR ASOs, and anything else I can think of.

### Setup

```{r setup, warning = FALSE}

# clear the global environment.
rm(list=ls())

# get packages.
suppressMessages(library(tidyverse))
library(readr)
library(Biostrings)
library(splitstackshape)
library(ensembldb)
library(EnsDb.Hsapiens.v86)
library(insect)

# for dealing with inserting objects into strings
library(glue)

```

### Data load and pre-processing

Starting with just the ABCB1 gene to reduce the load on my machine

```{r import, echo = TRUE, warning = FALSE}

# genseq_byaso <- read.csv("~/Initial_df_Transcripts_KW.csv", stringsAsFactors = FALSE)
genseq_byaso <- read.csv("../clean_aso_file.tsv", sep="", stringsAsFactors=FALSE)

aso_txt_pos <- genseq_byaso
#
## generate the reverse complement of the ASOs.
#genseq_byaso$aso_rc_seq <- rc(genseq_byaso$ASOseq)
#
## confirm geneID of isoform to transcript_id
#genseq_byaso$transcript_id <- gsub("\\..*","",genseq_byaso$hg38.knownGene.name)
#

```


### map coordinates

```{r transcriptomic coordinates, warning = FALSE}

## loop through each row to look for where each ASO sequence is located along the target transcript sequence. The'start' and 'end' positions are in relation to the start of the transcript and also represent character position within each transcript sequence string.
#
#aso_txt_pos <- genseq_byaso
#aso_txt_pos$start <- NA
#aso_txt_pos$end <- NA
#
#for(i in 1:dim(aso_txt_pos)[1]){
#  string <- genseq_byaso[i, "Sequence"]
#  pattern <- genseq_byaso[i, "aso_rc_seq"]
#
#  # search for matches in transcript and reduce df of those that do not match
#  coord <- as.data.frame(str_locate(string, pattern))
#  coord <- na.omit(coord)
#
#  # added if statement to ignore transcripts where there was no match
#  if (nrow(coord) == 1){
#    aso_txt_pos[i, "start"] <- coord[1, "start"]
#    aso_txt_pos[i, "end"] <- coord[1, "end"]
#  }
#}
#
#aso_txt_pos <- na.omit(aso_txt_pos)
#
## Do we expect any ASO to hit the same gene more than once? We may want to use str_locate_all()...

```

### Convert the transcriptomic coordinates into genomic coordinates


```{r genomic coordinates, warning = FALSE}

# convert the transcript position information into an IRanges format.
# ir <- IRanges(start = aso_txt_pos$start, end = aso_txt_pos$end, width = (aso_txt_pos$end - aso_txt_pos$start + 1), names = aso_txt_pos$transcript_id)

ir <- IRanges(start = aso_txt_pos$start, width = (aso_txt_pos$end - aso_txt_pos$start + 1), names = aso_txt_pos$transcript_id)

# create an EnsDB object containing genomic position information.
dbfile <- system.file("extdata/EnsDb.Hsapiens.v86.sqlite", package = "EnsDb.Hsapiens.v86")
db <- EnsDb(dbfile)

# this is actually something used down below but felt I should move it to a more "global" section
dna <- ensembldb::getGenomeTwoBitFile(db)

gr <- transcriptToGenome(ir, db)



# to convert the GRanges list to a GRanges object.
# gr <- unlist(gr)
```


### search for exon-exon ASOs

```{r}

aso_txt_pos$exon_exon_ASO <- NA

# loop through granges objects and search for ranges that span multiple exons
for (i in 1:length(gr)){
  # unlist each individual gr
  single_gr <- unlist(gr[i])

  # identify if the gr contains more than one exon
  if (length(single_gr) > 1){

    # set value of exon_exon column (1 = exon-exon, 0 = single exon)
    aso_txt_pos[i, "exon_exon_ASO"] <- as.integer(1)
  } else {
    aso_txt_pos[i, "exon_exon_ASO"] <- as.integer(0)
  }
}

```

### search for 5'-UTR-binding ASOs and 3'-UTR-binding ASOs


 ```{r}

# gather available chromosomes
chromes <- seqnames(seqinfo(dna))

# gather unique transcripts
# had to slice the unique transcripts because one of the transcripts is not actually protein-coding (do we want this one in here?)
# ^^^ the above doesn't work because I specified protein_coding in the "dna" variable call up above
# had to include the slice here to ignore transcripts that are on chromosomes not in 'x'
unique_transcripts <- unique(aso_txt_pos[aso_txt_pos$loci.value %in% chromes, ]$transcript_id)

# begin new start codon column
aso_txt_pos$start_codon_location <- NA
aso_txt_pos$last_nucelotide <- NA

# the tryCatch passes on transcripts that contain no cds (these are non-protein-coding transcripts)
for (transcript in unique_transcripts){

  tryCatch({

    # set up filter for specified transcript
    txflt <- AnnotationFilter(~ tx_id == transcript)

    # extract the whole transcript sequence for the specified transcript above
    cdna <- extractTranscriptSeqs(dna, db, filter=txflt)
    cdna <- toString(cdna)

    # extract the cds ( coding region only ) for the specified transcript above
    cds <- cdsBy(db, filter=txflt)
    cds <- extractTranscriptSeqs(dna, cds)
    cds <- toString(cds)

    # find where the cds portion of transcript starts within cdna
    start_codon_location <- as.data.frame(str_locate(cdna, cds))[1, 1]
    aso_txt_pos[aso_txt_pos$transcript_id == transcript, ]$start_codon_location <- start_codon_location

    # find where the cds portion of transcript ends within cdna
    last_nucleotide <- as.data.frame(str_locate(cdna, cds))[1, 1]
    aso_txt_pos[aso_txt_pos$transcript_id == transcript, ]$last_nucleotide <- last_nucleotide

  }, error=function(e){})
}

# initiate utr_bind column
aso_txt_pos$five_prime_utr_bind <- NA
aso_txt_pos$three_prime_utr_bind <- NA

# identify if the aso is binding upstream of the start codon (indicating binding to UTR)
# (this step may be able to be done in the loop above (although there are many asos / gene)
for (i in 1:nrow(aso_txt_pos)){

  # skip start codon locations with na
  # this na is occurring due to a bad request in the start codon location above
  if (!is.na(aso_txt_pos[i, "start_codon_location"])){

    # mark 1 for asos that do bind to utr, 0 for those that do not
    if (aso_txt_pos[i, "start"] < aso_txt_pos[i, "start_codon_location"]){
      aso_txt_pos[i, "five_prime_utr_bind"] <- as.integer(1)
    } else {
      aso_txt_pos[i, "five_prime_utr_bind"] <- as.integer(0)
    }
    }
}

# identify if the aso is binding downstream of the final nucleotide of the cdna (indicating 3' UTR bind)
for (i in 1:nrow(aso_txt_pos)){

  # skip last nucleotide locations with na
  # just copying what i have above for the five prime indentification
  # need to go back and confirm why this is happening
  if (!is.na(aso_txt_pos[i, "end"])){

    # mark 1 for asos that do bind to the 3' utr, 0 for those that do not
    if (aso_txt_pos[i, "end"] < aso_txt_pos[i, "last_nucleotide"]){
      aso_txt_pos[i, "three_prime_utr_bind"] <- as.integer(1)
    } else {
      aso_txt_pos[i, "three_prime_utr_bind"] <- as.integer(0)
    }
  }
}

```


### build gr df, combine with aso df, and write to tsv

```{r GRanges to BED format, warning = FALSE}

#gnm_df <- data.frame(loci = seqnames(gr),
#  starts = start(gr) - 1,
#  ends = end(gr)) %>%
#  dplyr::select(loci.group_name, loci.value, starts.value, ends.value)
#
#final_df <- full_join(aso_txt_pos, gnm_df, by = c('transcript_id' = 'loci.group_name'))


```

### write the final df
```{r}
gene_of_interest <- aso_txt_pos$GeneID[1]
file <- 'readydf_{gene_of_interest}.tsv'
file <- glue(file)

write.table(aso_txt_pos, file = file, sep = "\t", col.names = NA)
```

